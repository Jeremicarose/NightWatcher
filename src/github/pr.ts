/**
 * GitHub PR Creator
 *
 * Creates pull requests with fixes and escalation issues when fixes fail.
 * Uses Octokit to interact with GitHub API.
 */

import { Octokit } from '@octokit/rest';
import { createLogger } from '../utils/logger.js';
import type { FailureAnalysis, ProposedFix, GeneratedTest, FixAttempt } from '../types.js';

const logger = createLogger('PRCreator');

/**
 * Get authenticated Octokit client.
 */
function getOctokit(): Octokit {
  const token = process.env.GITHUB_TOKEN;

  if (!token) {
    throw new Error('GITHUB_TOKEN is not configured');
  }

  return new Octokit({ auth: token });
}

/**
 * Parse owner and repo from full repo name.
 */
function parseRepo(fullName: string): { owner: string; repo: string } {
  const [owner, repo] = fullName.split('/');
  return { owner, repo };
}

export interface PRContext {
  repo: string;           // "owner/repo"
  sha: string;            // Original failing commit SHA
  branch: string;         // Base branch (e.g., "main")
  analysis: FailureAnalysis;
  fix: ProposedFix;
  generatedTest?: GeneratedTest;
  fixAttempts: FixAttempt[];
}

export interface PRResult {
  success: boolean;
  pr_url?: string;
  pr_number?: number;
  error?: string;
}

/**
 * Create a pull request with the fix.
 *
 * Steps:
 * 1. Create a new branch
 * 2. Commit the fix
 * 3. Commit the test (if generated)
 * 4. Create the PR
 */
export async function createFixPR(context: PRContext): Promise<PRResult> {
  const { repo, sha, branch, analysis, fix, generatedTest } = context;
  const { owner, repo: repoName } = parseRepo(repo);

  logger.info('Creating fix PR', { repo, sha: sha.substring(0, 7) });

  try {
    const octokit = getOctokit();

    // Generate branch name
    const branchName = `nightwatch/fix-${sha.substring(0, 7)}-${Date.now()}`;

    // Step 1: Get the base branch ref
    logger.info('Getting base branch ref', { branch });
    const { data: refData } = await octokit.git.getRef({
      owner,
      repo: repoName,
      ref: `heads/${branch}`,
    });

    const baseSha = refData.object.sha;

    // Step 2: Create new branch
    logger.info('Creating branch', { branchName });
    await octokit.git.createRef({
      owner,
      repo: repoName,
      ref: `refs/heads/${branchName}`,
      sha: baseSha,
    });

    // Step 3: Get the current file content
    const { data: fileData } = await octokit.repos.getContent({
      owner,
      repo: repoName,
      path: fix.file_path,
      ref: branchName,
    });

    if (Array.isArray(fileData) || fileData.type !== 'file') {
      throw new Error(`${fix.file_path} is not a file`);
    }

    // Step 4: Apply the fix to file content
    const currentContent = Buffer.from(fileData.content, 'base64').toString('utf-8');
    const fixedContent = currentContent.replace(fix.original_code, fix.fixed_code);

    if (currentContent === fixedContent) {
      throw new Error('Fix did not change the file - original code not found');
    }

    // Step 5: Commit the fix
    logger.info('Committing fix', { filePath: fix.file_path });
    await octokit.repos.createOrUpdateFileContents({
      owner,
      repo: repoName,
      path: fix.file_path,
      message: `fix: ${fix.explanation}\n\nAuto-generated by Nightwatch`,
      content: Buffer.from(fixedContent).toString('base64'),
      sha: fileData.sha,
      branch: branchName,
    });

    // Step 6: Commit the test (if generated)
    if (generatedTest) {
      logger.info('Committing generated test', { testFile: generatedTest.target_file });

      try {
        // Check if test file exists
        const { data: testFileData } = await octokit.repos.getContent({
          owner,
          repo: repoName,
          path: generatedTest.target_file,
          ref: branchName,
        }).catch(() => ({ data: null }));

        let testContent: string;
        let testFileSha: string | undefined;

        if (testFileData && !Array.isArray(testFileData) && testFileData.type === 'file') {
          // Append to existing test file
          const existingContent = Buffer.from(testFileData.content, 'base64').toString('utf-8');
          testContent = existingContent.trimEnd() + '\n\n\n' + generatedTest.test_code + '\n';
          testFileSha = testFileData.sha;
        } else {
          // Create new test file
          const sourceModule = fix.file_path.split('/').pop()?.replace('.py', '') || 'module';
          testContent = `"""Auto-generated regression tests by Nightwatch."""
import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

from ${sourceModule} import ${generatedTest.imports_needed.join(', ')}


${generatedTest.test_code}
`;
        }

        await octokit.repos.createOrUpdateFileContents({
          owner,
          repo: repoName,
          path: generatedTest.target_file,
          message: `test: add regression test for ${analysis.error_type}\n\nAuto-generated by Nightwatch`,
          content: Buffer.from(testContent).toString('base64'),
          sha: testFileSha,
          branch: branchName,
        });
      } catch (testError) {
        logger.warn('Failed to commit test file', {
          error: testError instanceof Error ? testError.message : 'Unknown'
        });
        // Continue without the test - the fix is more important
      }
    }

    // Step 7: Create the PR
    logger.info('Creating pull request');
    const prBody = generatePRBody(context);

    const { data: pr } = await octokit.pulls.create({
      owner,
      repo: repoName,
      title: `üîß Nightwatch Auto-Fix: ${analysis.error_type} in ${fix.file_path}`,
      body: prBody,
      head: branchName,
      base: branch,
    });

    // Step 8: Add labels
    try {
      await octokit.issues.addLabels({
        owner,
        repo: repoName,
        issue_number: pr.number,
        labels: ['nightwatch', 'auto-fix'],
      });
    } catch {
      // Labels might not exist - that's OK
    }

    logger.info('PR created successfully', { pr_url: pr.html_url, pr_number: pr.number });

    return {
      success: true,
      pr_url: pr.html_url,
      pr_number: pr.number,
    };

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.error('Failed to create PR', { error: errorMessage });

    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Generate the PR body with fix explanation.
 */
function generatePRBody(context: PRContext): string {
  const { analysis, fix, generatedTest, fixAttempts } = context;

  let body = `## What happened

CI failed with:
\`\`\`
${analysis.error_type}: ${analysis.error_message}
\`\`\`

**Location:** \`${analysis.file_path}:${analysis.line_number || '?'}\`
`;

  if (analysis.failing_test) {
    body += `**Failing test:** \`${analysis.failing_test}\`\n`;
  }

  body += `
## Root Cause

${fix.explanation}

## The Fix

\`\`\`diff
- ${fix.original_code.split('\n').join('\n- ')}
+ ${fix.fixed_code.split('\n').join('\n+ ')}
\`\`\`
`;

  if (generatedTest) {
    body += `
## Regression Test

Added \`${generatedTest.test_name}\` to ensure this case is covered going forward.

\`\`\`python
${generatedTest.test_code}
\`\`\`
`;
  }

  body += `
## Verification

`;

  if (fixAttempts.length > 0) {
    const successfulAttempt = fixAttempts.find(a => a.test_result === 'pass');
    if (successfulAttempt) {
      body += `‚úÖ All tests passing (fixed on attempt ${successfulAttempt.attempt_number})\n`;
    }
  }

  body += `
---
*This PR was generated autonomously by [Nightwatch](https://github.com/Jeremicarose/NightWatcher) üåô*
`;

  return body;
}

export interface IssueContext {
  repo: string;
  sha: string;
  branch: string;
  analysis: FailureAnalysis;
  fixAttempts: FixAttempt[];
  error?: string;
}

export interface IssueResult {
  success: boolean;
  issue_url?: string;
  issue_number?: number;
  error?: string;
}

/**
 * Create an escalation issue when fix attempts fail.
 */
export async function createEscalationIssue(context: IssueContext): Promise<IssueResult> {
  const { repo, sha, analysis, fixAttempts, error } = context;
  const { owner, repo: repoName } = parseRepo(repo);

  logger.info('Creating escalation issue', { repo, sha: sha.substring(0, 7) });

  try {
    const octokit = getOctokit();

    const issueBody = generateIssueBody(context);

    const { data: issue } = await octokit.issues.create({
      owner,
      repo: repoName,
      title: `üö® Nightwatch needs help: ${analysis.error_type} in ${analysis.file_path}`,
      body: issueBody,
      labels: ['nightwatch', 'needs-help'],
    });

    logger.info('Issue created', { issue_url: issue.html_url, issue_number: issue.number });

    return {
      success: true,
      issue_url: issue.html_url,
      issue_number: issue.number,
    };

  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'Unknown error';
    logger.error('Failed to create issue', { error: errorMessage });

    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Generate the escalation issue body.
 */
function generateIssueBody(context: IssueContext): string {
  const { sha, analysis, fixAttempts, error } = context;

  let body = `## CI Failure Details

Nightwatch detected a CI failure but couldn't fix it automatically.

**Commit:** \`${sha.substring(0, 7)}\`
**Error Type:** \`${analysis.error_type}\`
**Location:** \`${analysis.file_path}:${analysis.line_number || '?'}\`
**Message:**
\`\`\`
${analysis.error_message}
\`\`\`
`;

  if (analysis.failing_test) {
    body += `**Failing test:** \`${analysis.failing_test}\`\n\n`;
  }

  if (analysis.raw_log_snippet) {
    body += `## Log Snippet

\`\`\`
${analysis.raw_log_snippet.substring(0, 1000)}
\`\`\`

`;
  }

  if (fixAttempts.length > 0) {
    body += `## Fix Attempts

Nightwatch tried ${fixAttempts.length} fix(es):

`;
    for (const attempt of fixAttempts) {
      body += `### Attempt ${attempt.attempt_number}

- **Approach:** ${attempt.proposed_fix.explanation}
- **Result:** ${attempt.test_result === 'pass' ? '‚úÖ Passed' : '‚ùå Failed'}
`;
      if (attempt.error_output) {
        body += `- **Error:**
\`\`\`
${attempt.error_output.substring(0, 500)}
\`\`\`
`;
      }
    }
  }

  if (error) {
    body += `## Why Nightwatch Couldn't Fix It

${error}

`;
  }

  body += `## Next Steps

1. Review the error details above
2. Investigate the root cause manually
3. Push a fix to resolve the CI failure

---
*This issue was created by [Nightwatch](https://github.com/Jeremicarose/NightWatcher) üåô*
`;

  return body;
}
